package uvtest

import (
	"context"
	"fmt"
	"io"
	"os"
	"path"
	"sync"
	"testing"

	uv "github.com/charmbracelet/ultraviolet"
	"github.com/charmbracelet/x/exp/golden"
	"github.com/charmbracelet/x/vt"
	"github.com/charmbracelet/x/xpty"
)

const (
	// DefaultWidth is the default width of a [TestTerminal].
	DefaultWidth = 80
	// DefaultHeight is the default height of a [TestTerminal].
	DefaultHeight = 24
)

// EventHandler represents an interface that can handle [uv.Event]s.
type EventHandler interface {
	HandleEvent(ev uv.Event)
}

// TestTerminal is a [uv.Screen] implementation that expands [uv.Terminal] for
// testing purposes.
type TestTerminal struct {
	*uv.Terminal
	testing.TB
	e      *vt.Emulator
	p      xpty.Pty
	mu     *sync.RWMutex
	sigch  chan struct{}
	evch   chan uv.Event
	ctx    context.Context
	cancel context.CancelFunc

	width  int
	height int
	env    []string

	frame int
}

// Wait waits until the terminal is closed.
func (tt *TestTerminal) Wait() {
	<-tt.ctx.Done()
}

// Resize resizes the terminal to the specified width and height.
func (tt *TestTerminal) Resize(width, height int) {
	tt.mu.Lock()
	defer tt.mu.Unlock()
	if err := tt.p.Resize(width, height); err != nil {
		tt.TB.Fatalf("failed to resize pty: %v", err)
	}
	tt.e.Resize(width, height)
	if err := tt.Terminal.Resize(width, height); err != nil {
		tt.TB.Fatalf("failed to resize terminal: %v", err)
	}
}

// SendText sends the provided text to the terminal as if it were typed by a user.
func (tt *TestTerminal) SendText(text string) {
	tt.mu.Lock()
	defer tt.mu.Unlock()
	tt.e.SendText(text)
}

// SendKey sends the provided key event to the terminal as if it were typed by a user.
func (tt *TestTerminal) SendKey(key uv.KeyEvent) {
	tt.mu.Lock()
	defer tt.mu.Unlock()
	tt.e.SendKey(key)
}

// SendMouse sends the provided mouse event to the terminal as if it were
// generated by a user.
func (tt *TestTerminal) SendMouse(m uv.MouseEvent) {
	tt.mu.Lock()
	defer tt.mu.Unlock()
	tt.e.SendMouse(m)
}

// Paste sends the provided text to the terminal as if it were pasted by a user.
func (tt *TestTerminal) Paste(text string) {
	tt.mu.Lock()
	defer tt.mu.Unlock()
	tt.e.Paste(text)
}

// Close closes the terminal and its underlying pty.
func (tt *TestTerminal) Close() error {
	tt.cancel()
	_ = tt.e.Close()
	defer func() {
		_ = tt.p.Close()
	}()
	return tt.Terminal.Close()
}

// Run starts reading events from the terminal and rendering changes using the
// provided [uv.Drawable]. It will record each render as a golden file using
// the name provided by the testing.TB instance and the frame number.
//
// Use [TestTerminal.SendText], [TestTerminal.SendKey],
// [TestTerminal.SendMouse], [TestTerminal.Paste], etc to send input to the
// terminal which will trigger renders.
func (tt *TestTerminal) Run(d uv.Drawable) {
	if err := tt.Start(); err != nil {
		tt.TB.Fatalf("failed to start terminal: %v", err)
	}
	if err := tt.Terminal.Resize(tt.width, tt.height); err != nil {
		tt.TB.Fatalf("failed to resize terminal: %v", err)
	}

	go func() {
		if err := tt.StreamEvents(tt.ctx, tt.evch); err != nil {
			tt.TB.Fatalf("failed to stream events: %v", err)
		}
	}()

	for {
		select {
		case <-tt.ctx.Done():
			return
		case ev := <-tt.evch:
			tt.Logf("event: %T %#v", ev, ev)
			switch d := d.(type) {
			case EventHandler:
				d.HandleEvent(ev)
			default:
				switch ev := ev.(type) {
				case uv.WindowSizeEvent:
					tt.Resize(ev.Width, ev.Height)
				case uv.KeyEvent:
					tt.SendKey(ev)
				case uv.MouseEvent:
					tt.SendMouse(ev)
				case uv.PasteEvent:
					tt.Paste(string(ev))
				default:
					tt.SendText(fmt.Sprint(ev))
				}
			}

			tt.frame++
			tt.Clear()
			d.Draw(tt.Terminal, tt.Terminal.Bounds())
			if err := tt.Display(); err != nil {
				tt.TB.Errorf("failed to display frame %d: %v", tt.frame, err)
			}

			if tt.Buffered() > 0 {
				// Wait for the display to complete before continuing.
				tt.Logf("waiting for display to complete for frame %d", tt.frame)
				<-tt.sigch
			}

			golden.RequireEqual(tname(tt, fmt.Sprintf("frame-%d", tt.frame)), tt.e.Render())
		}
	}
}

// Option is a functional option for configuring a [TestTerminal].
type Option func(*TestTerminal)

// WithSize sets the size of the [TestTerminal].
func WithSize(width, height int) Option {
	return func(tt *TestTerminal) {
		tt.width = width
		tt.height = height
	}
}

// WithEnvironment sets the environment variables of the [TestTerminal].
func WithEnvironment(env []string) Option {
	return func(tt *TestTerminal) {
		tt.env = env
	}
}

// NewTestTerminal creates a new [TestTerminal] instance.
func NewTestTerminal(t testing.TB, opts ...Option) *TestTerminal {
	t.Helper()
	tt := new(TestTerminal)
	tt.TB = t

	for _, opt := range opts {
		opt(tt)
	}

	if tt.width <= 0 {
		tt.width = DefaultWidth
	}
	if tt.height <= 0 {
		tt.height = DefaultHeight
	}
	if tt.env == nil {
		tt.env = os.Environ()
	}

	tt.ctx, tt.cancel = context.WithCancel(t.Context())

	t.Cleanup(tt.cancel)

	pty, err := xpty.NewPty(tt.width, tt.height)
	if err != nil {
		t.Fatalf("failed to create pty: %v", err)
	}

	var (
		in  io.Reader = pty
		out io.Writer = pty
	)
	switch p := pty.(type) {
	case *xpty.UnixPty:
		in = p.Slave()
		out = p.Slave()
	case *xpty.ConPty:
		in = p.InPipe()
		out = p.OutPipe()
	default:
		panic("unknown pty type")
	}

	sigCh := make(chan struct{})
	term := uv.NewTerminal(in, out, tt.env)
	e := vt.NewEmulator(tt.width, tt.height)
	mu := &sync.RWMutex{}
	sw := SignalWriter(tt.ctx, e, sigCh)

	go io.Copy(sw, pty) //nolint:errcheck
	go io.Copy(pty, e)  //nolint:errcheck

	tt.Terminal = term
	tt.e = e
	tt.p = pty
	tt.mu = mu
	tt.sigch = sigCh
	tt.evch = make(chan uv.Event)

	t.Cleanup(func() {
		_ = tt.Close()
	})

	return tt
}

type signalWriter struct {
	io.Writer
	sigCh chan struct{}
	ctx   context.Context
}

// Write implements [io.Writer].
func (s *signalWriter) Write(p []byte) (n int, err error) {
	n, err = s.Writer.Write(p)
	// select {
	// case <-s.ctx.Done():
	// 	err = s.ctx.Err()
	// case s.sigCh <- struct{}{}:
	// }
	return n, err
}

// SignalWriter wraps an [io.Writer] and sends a signal to the provided channel
// whenever a write occurs.
func SignalWriter(ctx context.Context, w io.Writer, sigCh chan struct{}) *signalWriter {
	return &signalWriter{
		Writer: w,
		sigCh:  sigCh,
		ctx:    ctx,
	}
}

// tbName is a helper to change the name of a [testing.TB] instance.
type tbName struct {
	testing.TB
	name string
}

// Name implements [testing.TB].
func (t *tbName) Name() string {
	return path.Join(t.TB.Name(), t.name)
}

func tname(t testing.TB, name string) *tbName {
	return &tbName{TB: t, name: name}
}
