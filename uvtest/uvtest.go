package uvtest

import (
	"fmt"
	"io"
	"os"
	"path"
	"sync"
	"testing"

	uv "github.com/charmbracelet/ultraviolet"
	"github.com/charmbracelet/x/exp/golden"
	"github.com/charmbracelet/x/vt"
	"github.com/charmbracelet/x/xpty"
)

const (
	// DefaultWidth is the default width of a [TestTerminal].
	DefaultWidth = 80
	// DefaultHeight is the default height of a [TestTerminal].
	DefaultHeight = 24
)

// EventHandler represents an interface that can handle [uv.Event]s.
type EventHandler interface {
	HandleEvent(ev uv.Event)
}

// TestTerminal is a [uv.Screen] implementation that expands [uv.Terminal] for
// testing purposes.
type TestTerminal struct {
	*uv.Terminal
	tb testing.TB
	e  *vt.Emulator
	p  xpty.Pty
	mu *sync.RWMutex

	width  int
	height int
	env    []string

	snaps int
}

// Resize resizes the terminal to the specified width and height.
func (tt *TestTerminal) Resize(width, height int) {
	tt.mu.Lock()
	defer tt.mu.Unlock()
	if err := tt.p.Resize(width, height); err != nil {
		tt.tb.Fatalf("failed to resize pty: %v", err)
	}
	tt.e.Resize(width, height)
	if err := tt.Terminal.Resize(width, height); err != nil {
		tt.tb.Fatalf("failed to resize terminal: %v", err)
	}
}

// SendText sends the provided text to the terminal as if it were typed by a user.
func (tt *TestTerminal) SendText(text string) {
	tt.mu.Lock()
	defer tt.mu.Unlock()
	tt.e.SendText(text)
}

// SendKey sends the provided key event to the terminal as if it were typed by a user.
func (tt *TestTerminal) SendKey(key uv.KeyEvent) {
	tt.mu.Lock()
	defer tt.mu.Unlock()
	tt.e.SendKey(key)
}

// SendMouse sends the provided mouse event to the terminal as if it were
// generated by a user.
func (tt *TestTerminal) SendMouse(m uv.MouseEvent) {
	tt.mu.Lock()
	defer tt.mu.Unlock()
	tt.e.SendMouse(m)
}

// Paste sends the provided text to the terminal as if it were pasted by a user.
func (tt *TestTerminal) Paste(text string) {
	tt.mu.Lock()
	defer tt.mu.Unlock()
	tt.e.Paste(text)
}

// Close closes the terminal and its underlying pty.
func (tt *TestTerminal) Close() error {
	_ = tt.e.Close()
	defer func() {
		_ = tt.p.Close()
	}()
	return tt.Terminal.Shutdown(tt.tb.Context())
}

// Snapshot records the current state of the terminal as a golden file using the name
// provided by the testing.TB instance and the snapshot number.
func (tt *TestTerminal) Snapshot() {
	tt.mu.RLock()
	defer tt.mu.RUnlock()
	golden.RequireEqual(tname(tt.tb, fmt.Sprintf("snapshot-%d", tt.snaps)), tt.e.Render())
	tt.snaps++
}

// Option is a functional option for configuring a [TestTerminal].
type Option func(*TestTerminal)

// WithSize sets the size of the [TestTerminal].
func WithSize(width, height int) Option {
	return func(tt *TestTerminal) {
		tt.width = width
		tt.height = height
	}
}

// WithEnvironment sets the environment variables of the [TestTerminal].
func WithEnvironment(env []string) Option {
	return func(tt *TestTerminal) {
		tt.env = env
	}
}

// NewTestTerminal creates a new [TestTerminal] instance and starts it.
func NewTestTerminal(t testing.TB, opts ...Option) (*TestTerminal, error) {
	t.Helper()
	tt := new(TestTerminal)
	tt.tb = t

	for _, opt := range opts {
		opt(tt)
	}

	if tt.width <= 0 {
		tt.width = DefaultWidth
	}
	if tt.height <= 0 {
		tt.height = DefaultHeight
	}
	if tt.env == nil {
		tt.env = os.Environ()
	}

	var err error
	tt.p, err = xpty.NewPty(tt.width, tt.height)
	if err != nil {
		return nil, fmt.Errorf("failed to create pty: %w", err)
	}

	var (
		in  io.Reader = tt.p
		out io.Writer = tt.p
	)
	switch p := tt.p.(type) {
	case *xpty.UnixPty:
		in = p.Slave()
		out = p.Slave()
	case *xpty.ConPty:
		in = p.InPipe()
		out = p.OutPipe()
	default:
		return nil, fmt.Errorf("unknown pty type: %T", tt.p)
	}

	tt.Terminal = uv.NewTerminal(in, out, tt.env)
	tt.e = vt.NewEmulator(tt.width, tt.height)
	tt.mu = &sync.RWMutex{}

	go io.Copy(tt.e, tt.p) //nolint:errcheck
	go io.Copy(tt.p, tt.e) //nolint:errcheck

	t.Cleanup(func() {
		_ = tt.Close()
	})

	if err := tt.Terminal.Start(); err != nil {
		return nil, fmt.Errorf("failed to start terminal: %w", err)
	}

	return tt, nil
}

// tbName is a helper to change the name of a [testing.TB] instance.
type tbName struct {
	testing.TB
	name string
}

// Name implements [testing.TB].
func (t *tbName) Name() string {
	return path.Join(t.TB.Name(), t.name)
}

func tname(t testing.TB, name string) *tbName {
	return &tbName{TB: t, name: name}
}
