package doc

import (
	uv "github.com/charmbracelet/ultraviolet"
	"golang.org/x/net/html"
)

// BoxType represents the type of box generated by an element.
type BoxType int

const (
	// BlockBox generates a block-level box
	BlockBox BoxType = iota
	// InlineBox generates an inline-level box
	InlineBox
	// AnonymousBlockBox is an anonymous block box (generated for block children of inline elements)
	AnonymousBlockBox
	// AnonymousInlineBox is an anonymous inline box (generated for text in block containers)
	AnonymousInlineBox
)

// Box represents a layout box in the box tree.
// Each node in the DOM can generate zero or more boxes.
type Box struct {
	Type     BoxType
	Node     *node           // The DOM node this box represents (nil for anonymous boxes)
	Style    *ComputedStyle  // Computed style for this box
	Children []*Box          // Child boxes
	Rect     uv.Rectangle    // Layout rectangle
	
	// For text boxes
	Text         string    // Text content (for text nodes)
	WrappedLines []uv.Line // Wrapped text lines (for inline boxes with text)
}

// NewBox creates a new box for a node.
func NewBox(node *node, boxType BoxType) *Box {
	return &Box{
		Type:     boxType,
		Node:     node,
		Style:    node.computedStyle,
		Children: make([]*Box, 0),
	}
}

// NewAnonymousBox creates a new anonymous box (no associated DOM node).
func NewAnonymousBox(boxType BoxType, style *ComputedStyle) *Box {
	return &Box{
		Type:     boxType,
		Node:     nil,
		Style:    style,
		Children: make([]*Box, 0),
	}
}

// IsBlock returns true if this is a block-level box.
func (b *Box) IsBlock() bool {
	return b.Type == BlockBox || b.Type == AnonymousBlockBox
}

// IsInline returns true if this is an inline-level box.
func (b *Box) IsInline() bool {
	return b.Type == InlineBox || b.Type == AnonymousInlineBox
}

// IsAnonymous returns true if this is an anonymous box.
func (b *Box) IsAnonymous() bool {
	return b.Type == AnonymousBlockBox || b.Type == AnonymousInlineBox
}

// buildBoxTree constructs the box tree from the DOM tree.
// This implements CSS 2.1 section 9.2.1.1 (anonymous box generation).
func buildBoxTree(n *node) *Box {
	if n == nil || n.computedStyle == nil {
		return nil
	}

	// Skip display:none elements
	if n.computedStyle.Display == DisplayNone {
		return nil
	}

	// Text nodes always generate inline boxes
	if n.Type() == html.TextNode {
		box := &Box{
			Type:  InlineBox,
			Node:  n,
			Style: n.computedStyle,
			Text:  n.Data(),
		}
		return box
	}

	// Determine box type from display property
	var boxType BoxType
	if n.computedStyle.Display == DisplayBlock {
		boxType = BlockBox
	} else {
		boxType = InlineBox
	}

	box := NewBox(n, boxType)

	// Process children
	children := n.Children()
	if len(children) == 0 {
		return box
	}

	// Build boxes for children
	var childBoxes []*Box
	for _, child := range children {
		if childNode, ok := child.(*node); ok {
			childBox := buildBoxTree(childNode)
			if childBox != nil {
				childBoxes = append(childBoxes, childBox)
			}
		}
	}

	// Apply anonymous box rules
	if box.IsBlock() {
		// Block box: create anonymous inline boxes for sequences of inline children
		box.Children = wrapInlineSequences(childBoxes, n.computedStyle)
	} else {
		// Inline box: create anonymous block boxes for block children
		box.Children = wrapBlockChildren(childBoxes, n.computedStyle)
	}

	return box
}

// wrapInlineSequences wraps consecutive inline boxes in anonymous block boxes.
// This implements CSS 2.1 section 9.2.1.1:
// "When an inline box contains an in-flow block-level box, the inline box
// is broken around the block-level box..."
func wrapInlineSequences(boxes []*Box, parentStyle *ComputedStyle) []*Box {
	if len(boxes) == 0 {
		return boxes
	}

	var result []*Box
	var inlineSequence []*Box

	for _, box := range boxes {
		if box.IsInline() {
			// Collect inline boxes
			inlineSequence = append(inlineSequence, box)
		} else {
			// Block box: wrap any pending inline sequence
			if len(inlineSequence) > 0 {
				anonBox := NewAnonymousBox(AnonymousBlockBox, parentStyle)
				anonBox.Children = inlineSequence
				result = append(result, anonBox)
				inlineSequence = nil
			}
			result = append(result, box)
		}
	}

	// Wrap remaining inline sequence
	if len(inlineSequence) > 0 {
		anonBox := NewAnonymousBox(AnonymousBlockBox, parentStyle)
		anonBox.Children = inlineSequence
		result = append(result, anonBox)
	}

	return result
}

// wrapBlockChildren wraps block-level boxes in anonymous inline boxes.
// This handles the case where a block box appears inside an inline box.
func wrapBlockChildren(boxes []*Box, parentStyle *ComputedStyle) []*Box {
	// For now, just return boxes as-is. Full implementation would handle
	// block-in-inline splitting per CSS 2.1 section 9.2.1.1.
	// This is a complex case that we'll defer for now.
	return boxes
}
